{"ast":null,"code":"import { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport range from 'lodash/range';\nimport { createPortal } from 'react-dom';\nimport { createUseStyles } from 'react-jss';\nimport round from 'lodash/round';\nimport isEqual from 'lodash/isEqual';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nvar mapRange = function (value, x1, y1, x2, y2) {\n  return (value - x1) * (y2 - x2) / (y1 - x1) + x2;\n};\nvar rotate = function (degree, amount) {\n  var result = degree + amount;\n  return result > 360 ? result - 360 : result;\n};\nvar coinFlip = function () {\n  return Math.random() > 0.5;\n};\n// avoid this for circles, as it will have no visual effect\nvar zAxisRotation = [0, 0, 1];\nvar rotationTransforms = [\n// dual axis rotations (a bit more realistic)\n[1, 1, 0], [1, 0, 1], [0, 1, 1],\n// single axis rotations (a bit dumber)\n[1, 0, 0], [0, 1, 0], zAxisRotation];\nvar shouldBeCircle = function (rotationIndex) {\n  return !isEqual(rotationTransforms[rotationIndex], zAxisRotation) && coinFlip();\n};\nvar ROTATION_SPEED_MIN = 200; // minimum possible duration of single particle full rotation\nvar ROTATION_SPEED_MAX = 800; // maximum possible duration of single particle full rotation\nvar CRAZY_PARTICLES_FREQUENCY = 0.1; // 0-1 frequency of crazy curvy unpredictable particles\nvar CRAZY_PARTICLE_CRAZINESS = 0.25; // 0-1 how crazy these crazy particles are\nvar BEZIER_MEDIAN = 0.5; // utility for mid-point bezier curves, to ensure smooth motion paths\nvar rotationKeyframes = rotationTransforms.reduce(function (acc, xyz, i) {\n  var _a;\n  return __assign(__assign({}, acc), (_a = {}, _a[\"@keyframes rotation-\".concat(i)] = {\n    '50%': {\n      transform: \"rotate3d(\".concat(xyz.map(function (v) {\n        return v / 2;\n      }).join(), \", 180deg)\")\n    },\n    '100%': {\n      transform: \"rotate3d(\".concat(xyz.join(), \", 360deg)\")\n    }\n  }, _a));\n}, {});\nvar confettiKeyframes = function (degrees, height, width) {\n  var y = typeof height === 'string' ? height : \"\".concat(height, \"px\");\n  var xLandingPoints = degrees.reduce(function (acc, degree, i) {\n    var _a;\n    var landingPoint = mapRange(Math.abs(rotate(degree, 90) - 180), 0, 180, -width / 2, width / 2);\n    return __assign(__assign({}, acc), (_a = {}, _a[\"@keyframes x-axis-\".concat(i)] = {\n      to: {\n        transform: \"translateX(\".concat(landingPoint, \"px)\")\n      }\n    }, _a));\n  }, {});\n  return __assign({\n    '@keyframes y-axis': {\n      to: {\n        transform: \"translateY(\".concat(y, \")\")\n      }\n    }\n  }, xLandingPoints);\n};\nvar confettoStyle = function (particle, duration, force, size, i) {\n  var _a;\n  var rotation = Math.round(Math.random() * (ROTATION_SPEED_MAX - ROTATION_SPEED_MIN) + ROTATION_SPEED_MIN);\n  var rotationIndex = Math.round(Math.random() * (rotationTransforms.length - 1));\n  var durationChaos = duration - Math.round(Math.random() * 1000);\n  var shouldBeCrazy = Math.random() < CRAZY_PARTICLES_FREQUENCY;\n  var isCircle = shouldBeCircle(rotationIndex);\n  // x-axis disturbance, roughly the distance the particle will initially deviate from its target\n  var x1 = shouldBeCrazy ? round(Math.random() * CRAZY_PARTICLE_CRAZINESS, 2) : 0;\n  var x2 = x1 * -1;\n  var x3 = x1;\n  // x-axis arc of explosion, so 90deg and 270deg particles have curve of 1, 0deg and 180deg have 0\n  var x4 = round(Math.abs(mapRange(Math.abs(rotate(particle.degree, 90) - 180), 0, 180, -1, 1)), 4);\n  // roughly how fast particle reaches end of its explosion curve\n  var y1 = round(Math.random() * BEZIER_MEDIAN, 4);\n  // roughly maps to the distance particle goes before reaching free-fall\n  var y2 = round(Math.random() * force * (coinFlip() ? 1 : -1), 4);\n  // roughly how soon the particle transitions from explosion to free-fall\n  var y3 = BEZIER_MEDIAN;\n  // roughly the ease of free-fall\n  var y4 = round(Math.max(mapRange(Math.abs(particle.degree - 180), 0, 180, force, -force), 0), 4);\n  return _a = {}, _a[\"&#confetti-particle-\".concat(i)] = {\n    animation: \"$x-axis-\".concat(i, \" \").concat(durationChaos, \"ms forwards cubic-bezier(\").concat(x1, \", \").concat(x2, \", \").concat(x3, \", \").concat(x4, \")\"),\n    '& > div': {\n      width: isCircle ? size : Math.round(Math.random() * 4) + size / 2,\n      height: isCircle ? size : Math.round(Math.random() * 2) + size,\n      animation: \"$y-axis \".concat(durationChaos, \"ms forwards cubic-bezier(\").concat(y1, \", \").concat(y2, \", \").concat(y3, \", \").concat(y4, \")\"),\n      '&:after': __assign({\n        backgroundColor: particle.color,\n        animation: \"$rotation-\".concat(rotationIndex, \" \").concat(rotation, \"ms infinite linear\")\n      }, isCircle ? {\n        borderRadius: '50%'\n      } : {})\n    }\n  }, _a;\n};\nvar useStyles = function (_a) {\n  var particles = _a.particles,\n    duration = _a.duration,\n    height = _a.height,\n    width = _a.width,\n    force = _a.force,\n    particleSize = _a.particleSize;\n  var confettiStyles = particles.reduce(function (acc, particle, i) {\n    return __assign(__assign({}, acc), confettoStyle(particle, duration, force, particleSize, i));\n  }, {});\n  return createUseStyles(__assign(__assign(__assign({}, rotationKeyframes), confettiKeyframes(particles.map(function (particle) {\n    return particle.degree;\n  }), height, width)), {\n    container: {\n      width: 0,\n      height: 0,\n      position: 'relative'\n    },\n    screen: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      overflow: 'hidden',\n      pointerEvents: 'none'\n    },\n    particle: __assign(__assign({}, confettiStyles), {\n      '& > div': {\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        '&:after': {\n          content: \"''\",\n          display: 'block',\n          width: '100%',\n          height: '100%'\n        }\n      }\n    })\n  }), {\n    name: 'confetti-explosion'\n  });\n};\nvar FORCE = 0.5; // 0-1 roughly the vertical force at which particles initially explode\nvar SIZE = 12; // max height for particle rectangles, diameter for particle circles\nvar HEIGHT = '120vh'; // distance particles will fall from initial explosion point\nvar WIDTH = 1000; // horizontal spread of particles in pixels\nvar PARTICLE_COUNT = 100;\nvar DURATION = 2200;\nvar COLORS = ['#FFC700', '#FF0000', '#2E3191', '#41BBC7'];\nvar createParticles = function (count, colors) {\n  var increment = 360 / count;\n  return range(count).map(function (index) {\n    return {\n      color: colors[index % colors.length],\n      degree: increment * index\n    };\n  });\n};\nfunction ConfettiExplosion(_a) {\n  var _b = _a.particleCount,\n    particleCount = _b === void 0 ? PARTICLE_COUNT : _b,\n    _c = _a.duration,\n    duration = _c === void 0 ? DURATION : _c,\n    _d = _a.colors,\n    colors = _d === void 0 ? COLORS : _d,\n    _e = _a.particleSize,\n    particleSize = _e === void 0 ? SIZE : _e,\n    _f = _a.force,\n    force = _f === void 0 ? FORCE : _f,\n    _g = _a.height,\n    height = _g === void 0 ? HEIGHT : _g,\n    _h = _a.width,\n    width = _h === void 0 ? WIDTH : _h,\n    zIndex = _a.zIndex,\n    onComplete = _a.onComplete,\n    props = __rest(_a, [\"particleCount\", \"duration\", \"colors\", \"particleSize\", \"force\", \"height\", \"width\", \"zIndex\", \"onComplete\"]);\n  var _j = React.useState(),\n    origin = _j[0],\n    setOrigin = _j[1];\n  var particles = createParticles(particleCount, colors);\n  var classes = useStyles({\n    particles: particles,\n    duration: duration,\n    particleSize: particleSize,\n    force: force,\n    width: width,\n    height: height\n  })();\n  var originRef = React.useCallback(function (node) {\n    if (node) {\n      var _a = node.getBoundingClientRect(),\n        top_1 = _a.top,\n        left = _a.left;\n      setOrigin({\n        top: top_1,\n        left: left\n      });\n    }\n  }, []);\n  React.useEffect(function () {\n    if (typeof onComplete === 'function') {\n      var timeout_1 = setTimeout(onComplete, duration);\n      return function () {\n        return clearTimeout(timeout_1);\n      };\n    }\n  }, [duration, onComplete]);\n  return jsx(\"div\", __assign({\n    ref: originRef,\n    className: classes.container\n  }, props, {\n    children: origin && createPortal(jsx(\"div\", __assign({\n      className: classes.screen\n    }, zIndex ? {\n      style: {\n        zIndex: zIndex\n      }\n    } : null, {\n      children: jsx(\"div\", __assign({\n        style: {\n          position: 'absolute',\n          top: origin.top,\n          left: origin.left\n        }\n      }, {\n        children: particles.map(function (particle, i) {\n          return jsx(\"div\", __assign({\n            id: \"confetti-particle-\".concat(i),\n            className: classes.particle\n          }, {\n            children: jsx(\"div\", {})\n          }), particle.degree);\n        })\n      }))\n    })), document.body)\n  }));\n}\nexport { ConfettiExplosion as default };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport range from 'lodash/range';\nimport { createPortal } from 'react-dom';\nimport { createUseStyles } from 'react-jss';\nimport round from 'lodash/round';\nimport isEqual from 'lodash/isEqual';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nvar mapRange = function (value, x1, y1, x2, y2) {\r\n    return ((value - x1) * (y2 - x2)) / (y1 - x1) + x2;\r\n};\r\nvar rotate = function (degree, amount) {\r\n    var result = degree + amount;\r\n    return result > 360 ? result - 360 : result;\r\n};\r\nvar coinFlip = function () { return Math.random() > 0.5; };\r\n// avoid this for circles, as it will have no visual effect\r\nvar zAxisRotation = [0, 0, 1];\r\nvar rotationTransforms = [\r\n    // dual axis rotations (a bit more realistic)\r\n    [1, 1, 0],\r\n    [1, 0, 1],\r\n    [0, 1, 1],\r\n    // single axis rotations (a bit dumber)\r\n    [1, 0, 0],\r\n    [0, 1, 0],\r\n    zAxisRotation,\r\n];\r\nvar shouldBeCircle = function (rotationIndex) {\r\n    return !isEqual(rotationTransforms[rotationIndex], zAxisRotation) && coinFlip();\r\n};\n\nvar ROTATION_SPEED_MIN = 200; // minimum possible duration of single particle full rotation\r\nvar ROTATION_SPEED_MAX = 800; // maximum possible duration of single particle full rotation\r\nvar CRAZY_PARTICLES_FREQUENCY = 0.1; // 0-1 frequency of crazy curvy unpredictable particles\r\nvar CRAZY_PARTICLE_CRAZINESS = 0.25; // 0-1 how crazy these crazy particles are\r\nvar BEZIER_MEDIAN = 0.5; // utility for mid-point bezier curves, to ensure smooth motion paths\r\nvar rotationKeyframes = rotationTransforms.reduce(function (acc, xyz, i) {\r\n    var _a;\r\n    return __assign(__assign({}, acc), (_a = {}, _a[\"@keyframes rotation-\".concat(i)] = {\r\n        '50%': {\r\n            transform: \"rotate3d(\".concat(xyz.map(function (v) { return v / 2; }).join(), \", 180deg)\"),\r\n        },\r\n        '100%': {\r\n            transform: \"rotate3d(\".concat(xyz.join(), \", 360deg)\"),\r\n        },\r\n    }, _a));\r\n}, {});\r\nvar confettiKeyframes = function (degrees, height, width) {\r\n    var y = typeof height === 'string' ? height : \"\".concat(height, \"px\");\r\n    var xLandingPoints = degrees.reduce(function (acc, degree, i) {\r\n        var _a;\r\n        var landingPoint = mapRange(Math.abs(rotate(degree, 90) - 180), 0, 180, -width / 2, width / 2);\r\n        return __assign(__assign({}, acc), (_a = {}, _a[\"@keyframes x-axis-\".concat(i)] = {\r\n            to: {\r\n                transform: \"translateX(\".concat(landingPoint, \"px)\"),\r\n            },\r\n        }, _a));\r\n    }, {});\r\n    return __assign({ '@keyframes y-axis': {\r\n            to: {\r\n                transform: \"translateY(\".concat(y, \")\"),\r\n            },\r\n        } }, xLandingPoints);\r\n};\r\nvar confettoStyle = function (particle, duration, force, size, i) {\r\n    var _a;\r\n    var rotation = Math.round(Math.random() * (ROTATION_SPEED_MAX - ROTATION_SPEED_MIN) + ROTATION_SPEED_MIN);\r\n    var rotationIndex = Math.round(Math.random() * (rotationTransforms.length - 1));\r\n    var durationChaos = duration - Math.round(Math.random() * 1000);\r\n    var shouldBeCrazy = Math.random() < CRAZY_PARTICLES_FREQUENCY;\r\n    var isCircle = shouldBeCircle(rotationIndex);\r\n    // x-axis disturbance, roughly the distance the particle will initially deviate from its target\r\n    var x1 = shouldBeCrazy ? round(Math.random() * CRAZY_PARTICLE_CRAZINESS, 2) : 0;\r\n    var x2 = x1 * -1;\r\n    var x3 = x1;\r\n    // x-axis arc of explosion, so 90deg and 270deg particles have curve of 1, 0deg and 180deg have 0\r\n    var x4 = round(Math.abs(mapRange(Math.abs(rotate(particle.degree, 90) - 180), 0, 180, -1, 1)), 4);\r\n    // roughly how fast particle reaches end of its explosion curve\r\n    var y1 = round(Math.random() * BEZIER_MEDIAN, 4);\r\n    // roughly maps to the distance particle goes before reaching free-fall\r\n    var y2 = round(Math.random() * force * (coinFlip() ? 1 : -1), 4);\r\n    // roughly how soon the particle transitions from explosion to free-fall\r\n    var y3 = BEZIER_MEDIAN;\r\n    // roughly the ease of free-fall\r\n    var y4 = round(Math.max(mapRange(Math.abs(particle.degree - 180), 0, 180, force, -force), 0), 4);\r\n    return _a = {},\r\n        _a[\"&#confetti-particle-\".concat(i)] = {\r\n            animation: \"$x-axis-\".concat(i, \" \").concat(durationChaos, \"ms forwards cubic-bezier(\").concat(x1, \", \").concat(x2, \", \").concat(x3, \", \").concat(x4, \")\"),\r\n            '& > div': {\r\n                width: isCircle ? size : Math.round(Math.random() * 4) + size / 2,\r\n                height: isCircle ? size : Math.round(Math.random() * 2) + size,\r\n                animation: \"$y-axis \".concat(durationChaos, \"ms forwards cubic-bezier(\").concat(y1, \", \").concat(y2, \", \").concat(y3, \", \").concat(y4, \")\"),\r\n                '&:after': __assign({ backgroundColor: particle.color, animation: \"$rotation-\".concat(rotationIndex, \" \").concat(rotation, \"ms infinite linear\") }, (isCircle ? { borderRadius: '50%' } : {})),\r\n            },\r\n        },\r\n        _a;\r\n};\r\nvar useStyles = function (_a) {\r\n    var particles = _a.particles, duration = _a.duration, height = _a.height, width = _a.width, force = _a.force, particleSize = _a.particleSize;\r\n    var confettiStyles = particles.reduce(function (acc, particle, i) { return (__assign(__assign({}, acc), confettoStyle(particle, duration, force, particleSize, i))); }, {});\r\n    return createUseStyles(__assign(__assign(__assign({}, rotationKeyframes), confettiKeyframes(particles.map(function (particle) { return particle.degree; }), height, width)), { container: {\r\n            width: 0,\r\n            height: 0,\r\n            position: 'relative',\r\n        }, screen: {\r\n            position: 'fixed',\r\n            top: 0,\r\n            left: 0,\r\n            right: 0,\r\n            bottom: 0,\r\n            overflow: 'hidden',\r\n            pointerEvents: 'none',\r\n        }, particle: __assign(__assign({}, confettiStyles), { '& > div': {\r\n                position: 'absolute',\r\n                left: 0,\r\n                top: 0,\r\n                '&:after': {\r\n                    content: \"''\",\r\n                    display: 'block',\r\n                    width: '100%',\r\n                    height: '100%',\r\n                },\r\n            } }) }), { name: 'confetti-explosion' });\r\n};\n\nvar FORCE = 0.5; // 0-1 roughly the vertical force at which particles initially explode\r\nvar SIZE = 12; // max height for particle rectangles, diameter for particle circles\r\nvar HEIGHT = '120vh'; // distance particles will fall from initial explosion point\r\nvar WIDTH = 1000; // horizontal spread of particles in pixels\r\nvar PARTICLE_COUNT = 100;\r\nvar DURATION = 2200;\r\nvar COLORS = ['#FFC700', '#FF0000', '#2E3191', '#41BBC7'];\r\nvar createParticles = function (count, colors) {\r\n    var increment = 360 / count;\r\n    return range(count).map(function (index) { return ({\r\n        color: colors[index % colors.length],\r\n        degree: increment * index,\r\n    }); });\r\n};\r\nfunction ConfettiExplosion(_a) {\r\n    var _b = _a.particleCount, particleCount = _b === void 0 ? PARTICLE_COUNT : _b, _c = _a.duration, duration = _c === void 0 ? DURATION : _c, _d = _a.colors, colors = _d === void 0 ? COLORS : _d, _e = _a.particleSize, particleSize = _e === void 0 ? SIZE : _e, _f = _a.force, force = _f === void 0 ? FORCE : _f, _g = _a.height, height = _g === void 0 ? HEIGHT : _g, _h = _a.width, width = _h === void 0 ? WIDTH : _h, zIndex = _a.zIndex, onComplete = _a.onComplete, props = __rest(_a, [\"particleCount\", \"duration\", \"colors\", \"particleSize\", \"force\", \"height\", \"width\", \"zIndex\", \"onComplete\"]);\r\n    var _j = React.useState(), origin = _j[0], setOrigin = _j[1];\r\n    var particles = createParticles(particleCount, colors);\r\n    var classes = useStyles({\r\n        particles: particles,\r\n        duration: duration,\r\n        particleSize: particleSize,\r\n        force: force,\r\n        width: width,\r\n        height: height,\r\n    })();\r\n    var originRef = React.useCallback(function (node) {\r\n        if (node) {\r\n            var _a = node.getBoundingClientRect(), top_1 = _a.top, left = _a.left;\r\n            setOrigin({ top: top_1, left: left });\r\n        }\r\n    }, []);\r\n    React.useEffect(function () {\r\n        if (typeof onComplete === 'function') {\r\n            var timeout_1 = setTimeout(onComplete, duration);\r\n            return function () { return clearTimeout(timeout_1); };\r\n        }\r\n    }, [duration, onComplete]);\r\n    return (jsx(\"div\", __assign({ ref: originRef, className: classes.container }, props, { children: origin &&\r\n            createPortal(jsx(\"div\", __assign({ className: classes.screen }, (zIndex ? { style: { zIndex: zIndex } } : null), { children: jsx(\"div\", __assign({ style: { position: 'absolute', top: origin.top, left: origin.left } }, { children: particles.map(function (particle, i) { return (jsx(\"div\", __assign({ id: \"confetti-particle-\".concat(i), className: classes.particle }, { children: jsx(\"div\", {}) }), particle.degree)); }) })) })), document.body) })));\r\n}\n\nexport { ConfettiExplosion as default };\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}