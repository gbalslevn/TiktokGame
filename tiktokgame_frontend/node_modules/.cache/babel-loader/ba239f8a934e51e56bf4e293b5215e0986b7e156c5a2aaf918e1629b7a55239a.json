{"ast":null,"code":"\"use strict\";\n\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nconst {\n  EventEmitter\n} = require('node:events');\nconst TikTokHttpClient = require('./lib/tiktokHttpClient.js');\nconst WebcastWebsocket = require('./lib/webcastWebsocket.js');\nconst {\n  getRoomIdFromMainPageHtml,\n  validateAndNormalizeUniqueId,\n  addUniqueId,\n  removeUniqueId\n} = require('./lib/tiktokUtils.js');\nconst {\n  simplifyObject\n} = require('./lib/webcastDataConverter.js');\nconst {\n  deserializeMessage,\n  deserializeWebsocketMessage\n} = require('./lib/webcastProtobuf.js');\nconst Config = require('./lib/webcastConfig.js');\nconst ControlEvents = {\n  CONNECTED: 'connected',\n  DISCONNECTED: 'disconnected',\n  ERROR: 'error',\n  RAWDATA: 'rawData',\n  DECODEDDATA: 'decodedData',\n  STREAMEND: 'streamEnd',\n  WSCONNECTED: 'websocketConnected'\n};\nconst MessageEvents = {\n  CHAT: 'chat',\n  MEMBER: 'member',\n  GIFT: 'gift',\n  ROOMUSER: 'roomUser',\n  SOCIAL: 'social',\n  LIKE: 'like',\n  QUESTIONNEW: 'questionNew',\n  LINKMICBATTLE: 'linkMicBattle',\n  LINKMICARMIES: 'linkMicArmies',\n  LIVEINTRO: 'liveIntro',\n  EMOTE: 'emote',\n  ENVELOPE: 'envelope',\n  SUBSCRIBE: 'subscribe'\n};\nconst CustomEvents = {\n  FOLLOW: 'follow',\n  SHARE: 'share'\n};\n/**\n * Wrapper class for TikTok's internal Webcast Push Service\n */\n\nvar _options = /*#__PURE__*/new WeakMap();\nvar _uniqueStreamerId = /*#__PURE__*/new WeakMap();\nvar _roomId = /*#__PURE__*/new WeakMap();\nvar _roomInfo = /*#__PURE__*/new WeakMap();\nvar _clientParams = /*#__PURE__*/new WeakMap();\nvar _httpClient = /*#__PURE__*/new WeakMap();\nvar _availableGifts = /*#__PURE__*/new WeakMap();\nvar _websocket = /*#__PURE__*/new WeakMap();\nvar _isConnecting = /*#__PURE__*/new WeakMap();\nvar _isConnected = /*#__PURE__*/new WeakMap();\nvar _isPollingEnabled = /*#__PURE__*/new WeakMap();\nvar _isWsUpgradeDone = /*#__PURE__*/new WeakMap();\nvar _setOptions = /*#__PURE__*/new WeakSet();\nvar _setUnconnected = /*#__PURE__*/new WeakSet();\nvar _retrieveRoomId = /*#__PURE__*/new WeakSet();\nvar _fetchRoomInfo = /*#__PURE__*/new WeakSet();\nvar _fetchAvailableGifts = /*#__PURE__*/new WeakSet();\nvar _startFetchRoomPolling = /*#__PURE__*/new WeakSet();\nvar _fetchRoomData = /*#__PURE__*/new WeakSet();\nvar _tryUpgradeToWebsocket = /*#__PURE__*/new WeakSet();\nvar _setupWebsocket = /*#__PURE__*/new WeakSet();\nvar _processWebcastResponse = /*#__PURE__*/new WeakSet();\nvar _handleError = /*#__PURE__*/new WeakSet();\nclass WebcastPushConnection extends EventEmitter {\n  // Websocket\n  // State\n\n  /**\n   * Create a new WebcastPushConnection instance\n   * @param {string} uniqueId TikTok username (from URL)\n   * @param {object} [options] Connection options\n   * @param {boolean} [options[].processInitialData=true] Process the initital data which includes messages of the last minutes\n   * @param {boolean} [options[].fetchRoomInfoOnConnect=true] Fetch the room info (room status, streamer info, etc.) on connect (will be returned when calling connect())\n   * @param {boolean} [options[].enableExtendedGiftInfo=false] Enable this option to get extended information on 'gift' events like gift name and cost\n   * @param {boolean} [options[].enableWebsocketUpgrade=true] Use WebSocket instead of request polling if TikTok offers it\n   * @param {boolean} [options[].enableRequestPolling=true] Use request polling if no WebSocket upgrade is offered. If `false` an exception will be thrown if TikTok does not offer a WebSocket upgrade.\n   * @param {number} [options[].requestPollingIntervalMs=1000] Request polling interval if WebSocket is not used\n   * @param {string} [options[].sessionId=null] The session ID from the \"sessionid\" cookie is required if you want to send automated messages in the chat.\n   * @param {object} [options[].clientParams={}] Custom client params for Webcast API\n   * @param {object} [options[].requestHeaders={}] Custom request headers for axios\n   * @param {object} [options[].websocketHeaders={}] Custom request headers for websocket.client\n   * @param {object} [options[].requestOptions={}] Custom request options for axios. Here you can specify an `httpsAgent` to use a proxy and a `timeout` value for example.\n   * @param {object} [options[].websocketOptions={}] Custom request options for websocket.client. Here you can specify an `agent` to use a proxy and a `timeout` value for example.\n   */\n  constructor(uniqueId, options) {\n    super();\n    _classPrivateMethodInitSpec(this, _handleError);\n    _classPrivateMethodInitSpec(this, _processWebcastResponse);\n    _classPrivateMethodInitSpec(this, _setupWebsocket);\n    _classPrivateMethodInitSpec(this, _tryUpgradeToWebsocket);\n    _classPrivateMethodInitSpec(this, _fetchRoomData);\n    _classPrivateMethodInitSpec(this, _startFetchRoomPolling);\n    _classPrivateMethodInitSpec(this, _fetchAvailableGifts);\n    _classPrivateMethodInitSpec(this, _fetchRoomInfo);\n    _classPrivateMethodInitSpec(this, _retrieveRoomId);\n    _classPrivateMethodInitSpec(this, _setUnconnected);\n    _classPrivateMethodInitSpec(this, _setOptions);\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _uniqueStreamerId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _roomId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _roomInfo, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _clientParams, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _httpClient, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _availableGifts, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _isConnecting, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _isConnected, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _isPollingEnabled, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _isWsUpgradeDone, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateMethodGet(this, _setOptions, _setOptions2).call(this, options || {});\n    _classPrivateFieldSet(this, _uniqueStreamerId, validateAndNormalizeUniqueId(uniqueId));\n    _classPrivateFieldSet(this, _httpClient, new TikTokHttpClient(_classPrivateFieldGet(this, _options).requestHeaders, _classPrivateFieldGet(this, _options).requestOptions, _classPrivateFieldGet(this, _options).sessionId));\n    _classPrivateFieldSet(this, _clientParams, {\n      ...Config.DEFAULT_CLIENT_PARAMS,\n      ..._classPrivateFieldGet(this, _options).clientParams\n    });\n    _classPrivateMethodGet(this, _setUnconnected, _setUnconnected2).call(this);\n  }\n\n  /**\n   * Connects to the current live stream room\n   * @param {string} [roomId] If you want to connect to a specific roomId. Otherwise the current roomId will be retrieved.\n   * @returns {Promise} Promise that will be resolved when the connection is established.\n   */\n  async connect(roomId = null) {\n    if (_classPrivateFieldGet(this, _isConnecting)) {\n      throw new Error('Already connecting!');\n    }\n    if (_classPrivateFieldGet(this, _isConnected)) {\n      throw new Error('Already connected!');\n    }\n    _classPrivateFieldSet(this, _isConnecting, true); // add streamerId to uu\n\n    addUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n    try {\n      // roomId already specified?\n      if (roomId) {\n        _classPrivateFieldSet(this, _roomId, roomId);\n        _classPrivateFieldGet(this, _clientParams).room_id = roomId;\n      } else {\n        await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n      } // Fetch room info if option enabled\n\n      if (_classPrivateFieldGet(this, _options).fetchRoomInfoOnConnect) {\n        await _classPrivateMethodGet(this, _fetchRoomInfo, _fetchRoomInfo2).call(this); // Prevent connections to finished rooms\n\n        if (_classPrivateFieldGet(this, _roomInfo).status === 4) {\n          throw new Error('LIVE has ended');\n        }\n      } // Fetch all available gift info if option enabled\n\n      if (_classPrivateFieldGet(this, _options).enableExtendedGiftInfo) {\n        await _classPrivateMethodGet(this, _fetchAvailableGifts, _fetchAvailableGifts2).call(this);\n      }\n      await _classPrivateMethodGet(this, _fetchRoomData, _fetchRoomData2).call(this, true); // Sometimes no upgrade to WebSocket is offered by TikTok\n      // In that case we use request polling (if enabled and possible)\n\n      if (!_classPrivateFieldGet(this, _isWsUpgradeDone)) {\n        if (!_classPrivateFieldGet(this, _options).enableRequestPolling) {\n          throw new Error('TikTok does not offer a websocket upgrade and request polling is disabled (`enableRequestPolling` option).');\n        }\n        if (!_classPrivateFieldGet(this, _options).sessionId) {\n          // We cannot use request polling if the user has no sessionid defined.\n          // The reason for this is that TikTok needs a valid signature if the user is not logged in.\n          // Signing a request every second would generate too much traffic to the signing server.\n          // If a sessionid is present a signature is not required.\n          throw new Error('TikTok does not offer a websocket upgrade. Please provide a valid `sessionId` to use request polling instead.');\n        }\n        _classPrivateMethodGet(this, _startFetchRoomPolling, _startFetchRoomPolling2).call(this);\n      }\n      _classPrivateFieldSet(this, _isConnected, true);\n      let state = this.getState();\n      this.emit(ControlEvents.CONNECTED, state);\n      return state;\n    } catch (err) {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Error while connecting'); // remove streamerId from uu on connect fail\n\n      removeUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n      throw err;\n    } finally {\n      _classPrivateFieldSet(this, _isConnecting, false);\n    }\n  }\n  /**\n   * Disconnects the connection to the live stream\n   */\n\n  disconnect() {\n    if (_classPrivateFieldGet(this, _isConnected)) {\n      if (_classPrivateFieldGet(this, _isWsUpgradeDone) && _classPrivateFieldGet(this, _websocket).connection.connected) {\n        _classPrivateFieldGet(this, _websocket).connection.close();\n      } // Reset state\n\n      _classPrivateMethodGet(this, _setUnconnected, _setUnconnected2).call(this); // remove streamerId from uu\n\n      removeUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n      this.emit(ControlEvents.DISCONNECTED);\n    }\n  }\n  /**\n   * Get the current connection state including the cached room info and all available gifts (if `enableExtendedGiftInfo` option enabled)\n   * @returns {object} current state object\n   */\n\n  getState() {\n    return {\n      isConnected: _classPrivateFieldGet(this, _isConnected),\n      upgradedToWebsocket: _classPrivateFieldGet(this, _isWsUpgradeDone),\n      roomId: _classPrivateFieldGet(this, _roomId),\n      roomInfo: _classPrivateFieldGet(this, _roomInfo),\n      availableGifts: _classPrivateFieldGet(this, _availableGifts)\n    };\n  }\n  /**\n   * Get the current room info (including streamer info, room status and statistics)\n   * @returns {Promise} Promise that will be resolved when the room info has been retrieved from the API\n   */\n\n  async getRoomInfo() {\n    // Retrieve current room_id if not connected\n    if (!_classPrivateFieldGet(this, _isConnected)) {\n      await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n    }\n    await _classPrivateMethodGet(this, _fetchRoomInfo, _fetchRoomInfo2).call(this);\n    return _classPrivateFieldGet(this, _roomInfo);\n  }\n  /**\n   * Get a list of all available gifts including gift name, image url, diamont cost and a lot of other information\n   * @returns {Promise} Promise that will be resolved when all available gifts has been retrieved from the API\n   */\n\n  async getAvailableGifts() {\n    await _classPrivateMethodGet(this, _fetchAvailableGifts, _fetchAvailableGifts2).call(this);\n    return _classPrivateFieldGet(this, _availableGifts);\n  }\n  /**\n   * Sends a chat message into the current live room using the provided session cookie\n   * @param {string} text Message Content\n   * @param {string} [sessionId] The \"sessionid\" cookie value from your TikTok Website if not provided via the constructor options\n   * @returns {Promise} Promise that will be resolved when the chat message has been submitted to the API\n   */\n\n  async sendMessage(text, sessionId) {\n    var _response$data;\n    if (sessionId) {\n      // Update sessionId\n      _classPrivateFieldGet(this, _options).sessionId = sessionId;\n    }\n    if (!_classPrivateFieldGet(this, _options).sessionId) {\n      throw new Error('Missing SessionId. Please provide your current SessionId to use this feature.');\n    }\n    try {\n      // Retrieve current room_id if not connected\n      if (!_classPrivateFieldGet(this, _isConnected)) {\n        await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n      } // Add the session cookie to the CookieJar\n\n      _classPrivateFieldGet(this, _httpClient).setSessionId(_classPrivateFieldGet(this, _options).sessionId); // Submit the chat request\n\n      let requestParams = {\n        ..._classPrivateFieldGet(this, _clientParams),\n        content: text\n      };\n      let response = await _classPrivateFieldGet(this, _httpClient).postFormDataToWebcastApi('room/chat/', requestParams, null); // Success?\n\n      if ((response === null || response === void 0 ? void 0 : response.status_code) === 0) {\n        return response.data;\n      } // Handle errors\n\n      switch (response === null || response === void 0 ? void 0 : response.status_code) {\n        case 20003:\n          throw new Error('Your SessionId has expired. Please provide a new one.');\n        default:\n          throw new Error(`TikTok responded with status code ${response === null || response === void 0 ? void 0 : response.status_code}: ${response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.message}`);\n      }\n    } catch (err) {\n      throw new Error(`Failed to send chat message. ${err.message}`);\n    }\n  }\n  /**\n   * Decodes and processes a binary webcast data package that you have received via the `rawData` event (for debugging purposes only)\n   * @param {string} messageType\n   * @param {Buffer} messageBuffer\n   */\n\n  async decodeProtobufMessage(messageType, messageBuffer) {\n    switch (messageType) {\n      case 'WebcastResponse':\n        {\n          let decodedWebcastResponse = deserializeMessage(messageType, messageBuffer);\n          _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, decodedWebcastResponse);\n          break;\n        }\n      case 'WebcastWebsocketMessage':\n        {\n          let decodedWebcastWebsocketMessage = await deserializeWebsocketMessage(messageBuffer);\n          if (typeof decodedWebcastWebsocketMessage.webcastResponse === 'object') {\n            _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, decodedWebcastWebsocketMessage.webcastResponse);\n          }\n          break;\n        }\n      default:\n        {\n          let webcastMessage = deserializeMessage(messageType, messageBuffer);\n          _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, {\n            messages: [{\n              decodedData: webcastMessage,\n              type: messageType\n            }]\n          });\n        }\n    }\n  }\n}\nfunction _setOptions2(providedOptions) {\n  _classPrivateFieldSet(this, _options, Object.assign({\n    // Default\n    processInitialData: true,\n    fetchRoomInfoOnConnect: true,\n    enableExtendedGiftInfo: false,\n    enableWebsocketUpgrade: true,\n    enableRequestPolling: true,\n    requestPollingIntervalMs: 1000,\n    sessionId: null,\n    clientParams: {},\n    requestHeaders: {},\n    websocketHeaders: {},\n    requestOptions: {},\n    websocketOptions: {}\n  }, providedOptions));\n}\nfunction _setUnconnected2() {\n  _classPrivateFieldSet(this, _roomInfo, null);\n  _classPrivateFieldSet(this, _isConnecting, false);\n  _classPrivateFieldSet(this, _isConnected, false);\n  _classPrivateFieldSet(this, _isPollingEnabled, false);\n  _classPrivateFieldSet(this, _isWsUpgradeDone, false);\n  _classPrivateFieldGet(this, _clientParams).cursor = '';\n  _classPrivateFieldGet(this, _clientParams).internal_ext = '';\n}\nasync function _retrieveRoomId2() {\n  try {\n    let mainPageHtml = await _classPrivateFieldGet(this, _httpClient).getMainPage(`@${_classPrivateFieldGet(this, _uniqueStreamerId)}/live`);\n    try {\n      let roomId = getRoomIdFromMainPageHtml(mainPageHtml);\n      _classPrivateFieldSet(this, _roomId, roomId);\n      _classPrivateFieldGet(this, _clientParams).room_id = roomId;\n    } catch (err) {\n      // Use fallback method\n      let roomData = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromTiktokApi('api-live/user/room/', {\n        ..._classPrivateFieldGet(this, _clientParams),\n        uniqueId: _classPrivateFieldGet(this, _uniqueStreamerId),\n        sourceType: 54\n      });\n      if (roomData.statusCode) throw new Error(`API Error ${roomData.statusCode} (${roomData.message || 'Unknown Error'})`);\n      _classPrivateFieldSet(this, _roomId, roomData.data.user.roomId);\n      _classPrivateFieldGet(this, _clientParams).room_id = roomData.data.user.roomId;\n    }\n  } catch (err) {\n    throw new Error(`Failed to retrieve room_id from page source. ${err.message}`);\n  }\n}\nasync function _fetchRoomInfo2() {\n  try {\n    let response = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromWebcastApi('room/info/', _classPrivateFieldGet(this, _clientParams));\n    _classPrivateFieldSet(this, _roomInfo, response.data);\n  } catch (err) {\n    throw new Error(`Failed to fetch room info. ${err.message}`);\n  }\n}\nasync function _fetchAvailableGifts2() {\n  try {\n    let response = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromWebcastApi('gift/list/', _classPrivateFieldGet(this, _clientParams));\n    _classPrivateFieldSet(this, _availableGifts, response.data.gifts);\n  } catch (err) {\n    throw new Error(`Failed to fetch available gifts. ${err.message}`);\n  }\n}\nasync function _startFetchRoomPolling2() {\n  _classPrivateFieldSet(this, _isPollingEnabled, true);\n  let sleepMs = ms => new Promise(resolve => setTimeout(resolve, ms));\n  while (_classPrivateFieldGet(this, _isPollingEnabled)) {\n    try {\n      await _classPrivateMethodGet(this, _fetchRoomData, _fetchRoomData2).call(this, false);\n    } catch (err) {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Error while fetching webcast data via request polling');\n    }\n    await sleepMs(_classPrivateFieldGet(this, _options).requestPollingIntervalMs);\n  }\n}\nasync function _fetchRoomData2(isInitial) {\n  let webcastResponse = await _classPrivateFieldGet(this, _httpClient).getDeserializedObjectFromWebcastApi('im/fetch/', _classPrivateFieldGet(this, _clientParams), 'WebcastResponse', isInitial);\n  let upgradeToWsOffered = !!webcastResponse.wsUrl;\n  if (!webcastResponse.cursor) {\n    if (isInitial) {\n      throw new Error('Missing cursor in initial fetch response.');\n    } else {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, null, 'Missing cursor in fetch response.');\n    }\n  } // Set cursor and internal_ext param to continue with the next request\n\n  if (webcastResponse.cursor) _classPrivateFieldGet(this, _clientParams).cursor = webcastResponse.cursor;\n  if (webcastResponse.internalExt) _classPrivateFieldGet(this, _clientParams).internal_ext = webcastResponse.internalExt;\n  if (isInitial) {\n    // Upgrade to Websocket offered? => Try upgrade\n    if (_classPrivateFieldGet(this, _options).enableWebsocketUpgrade && upgradeToWsOffered) {\n      await _classPrivateMethodGet(this, _tryUpgradeToWebsocket, _tryUpgradeToWebsocket2).call(this, webcastResponse);\n    }\n  } // Skip processing initial data if option disabled\n\n  if (isInitial && !_classPrivateFieldGet(this, _options).processInitialData) {\n    return;\n  }\n  _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, webcastResponse);\n}\nasync function _tryUpgradeToWebsocket2(webcastResponse) {\n  try {\n    var _webcastResponse$wsPa;\n\n    // Websocket specific params\n    let wsParams = {\n      imprp: ((_webcastResponse$wsPa = webcastResponse.wsParam) === null || _webcastResponse$wsPa === void 0 ? void 0 : _webcastResponse$wsPa.value) || '',\n      compress: 'gzip'\n    }; // Wait until ws connected, then stop request polling\n\n    await _classPrivateMethodGet(this, _setupWebsocket, _setupWebsocket2).call(this, webcastResponse.wsUrl, wsParams);\n    _classPrivateFieldSet(this, _isWsUpgradeDone, true);\n    _classPrivateFieldSet(this, _isPollingEnabled, false);\n    this.emit(ControlEvents.WSCONNECTED, _classPrivateFieldGet(this, _websocket));\n  } catch (err) {\n    _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Upgrade to websocket failed');\n  }\n}\nasync function _setupWebsocket2(wsUrl, wsParams) {\n  return new Promise((resolve, reject) => {\n    _classPrivateFieldSet(this, _websocket, new WebcastWebsocket(wsUrl, _classPrivateFieldGet(this, _httpClient).cookieJar, _classPrivateFieldGet(this, _clientParams), wsParams, _classPrivateFieldGet(this, _options).websocketHeaders, _classPrivateFieldGet(this, _options).websocketOptions));\n    _classPrivateFieldGet(this, _websocket).on('connect', wsConnection => {\n      resolve();\n      wsConnection.on('error', err => _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Websocket Error'));\n      wsConnection.on('close', () => {\n        this.disconnect();\n      });\n    });\n    _classPrivateFieldGet(this, _websocket).on('connectFailed', err => reject(`Websocket connection failed, ${err}`));\n    _classPrivateFieldGet(this, _websocket).on('webcastResponse', msg => _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, msg));\n    _classPrivateFieldGet(this, _websocket).on('messageDecodingFailed', err => _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Websocket message decoding failed')); // Hard timeout if the WebSocketClient library does not handle connect errors correctly.\n\n    setTimeout(() => reject('Websocket not responding'), 30000);\n  });\n}\nfunction _processWebcastResponse2(webcastResponse) {\n  // Emit raw (protobuf encoded) data for a use case specific processing\n  webcastResponse.messages.forEach(message => {\n    this.emit(ControlEvents.RAWDATA, message.type, message.binary);\n  }); // Process and emit decoded data depending on the the message type\n\n  webcastResponse.messages.filter(x => x.decodedData).forEach(message => {\n    var _simplifiedObj$displa, _simplifiedObj$displa2;\n    let simplifiedObj = simplifyObject(message.decodedData);\n    this.emit(ControlEvents.DECODEDDATA, message.type, simplifiedObj, message.binary);\n    switch (message.type) {\n      case 'WebcastControlMessage':\n        // Known control actions:\n        // 3 = Stream terminated by user\n        // 4 = Stream terminated by platform moderator (ban)\n        const action = message.decodedData.action;\n        if ([3, 4].includes(action)) {\n          this.emit(ControlEvents.STREAMEND, {\n            action\n          });\n          this.disconnect();\n        }\n        break;\n      case 'WebcastRoomUserSeqMessage':\n        this.emit(MessageEvents.ROOMUSER, simplifiedObj);\n        break;\n      case 'WebcastChatMessage':\n        this.emit(MessageEvents.CHAT, simplifiedObj);\n        break;\n      case 'WebcastMemberMessage':\n        this.emit(MessageEvents.MEMBER, simplifiedObj);\n        break;\n      case 'WebcastGiftMessage':\n        // Add extended gift info if option enabled\n        if (Array.isArray(_classPrivateFieldGet(this, _availableGifts)) && simplifiedObj.giftId) {\n          simplifiedObj.extendedGiftInfo = _classPrivateFieldGet(this, _availableGifts).find(x => x.id === simplifiedObj.giftId);\n        }\n        this.emit(MessageEvents.GIFT, simplifiedObj);\n        break;\n      case 'WebcastSocialMessage':\n        this.emit(MessageEvents.SOCIAL, simplifiedObj);\n        if ((_simplifiedObj$displa = simplifiedObj.displayType) !== null && _simplifiedObj$displa !== void 0 && _simplifiedObj$displa.includes('follow')) {\n          this.emit(CustomEvents.FOLLOW, simplifiedObj);\n        }\n        if ((_simplifiedObj$displa2 = simplifiedObj.displayType) !== null && _simplifiedObj$displa2 !== void 0 && _simplifiedObj$displa2.includes('share')) {\n          this.emit(CustomEvents.SHARE, simplifiedObj);\n        }\n        break;\n      case 'WebcastLikeMessage':\n        this.emit(MessageEvents.LIKE, simplifiedObj);\n        break;\n      case 'WebcastQuestionNewMessage':\n        this.emit(MessageEvents.QUESTIONNEW, simplifiedObj);\n        break;\n      case 'WebcastLinkMicBattle':\n        this.emit(MessageEvents.LINKMICBATTLE, simplifiedObj);\n        break;\n      case 'WebcastLinkMicArmies':\n        this.emit(MessageEvents.LINKMICARMIES, simplifiedObj);\n        break;\n      case 'WebcastLiveIntroMessage':\n        this.emit(MessageEvents.LIVEINTRO, simplifiedObj);\n        break;\n      case 'WebcastEmoteChatMessage':\n        this.emit(MessageEvents.EMOTE, simplifiedObj);\n        break;\n      case 'WebcastEnvelopeMessage':\n        this.emit(MessageEvents.ENVELOPE, simplifiedObj);\n        break;\n      case 'WebcastSubNotifyMessage':\n        this.emit(MessageEvents.SUBSCRIBE, simplifiedObj);\n        break;\n    }\n  });\n}\nfunction _handleError2(exception, info) {\n  if (this.listenerCount(ControlEvents.ERROR) > 0) {\n    this.emit(ControlEvents.ERROR, {\n      info,\n      exception\n    });\n  }\n}\nmodule.exports = {\n  WebcastPushConnection,\n  signatureProvider: require('./lib/tiktokSignatureProvider'),\n  webcastProtobuf: require('./lib/webcastProtobuf.js')\n};","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","_classPrivateMethodGet","fn","EventEmitter","require","TikTokHttpClient","WebcastWebsocket","getRoomIdFromMainPageHtml","validateAndNormalizeUniqueId","addUniqueId","removeUniqueId","simplifyObject","deserializeMessage","deserializeWebsocketMessage","Config","ControlEvents","CONNECTED","DISCONNECTED","ERROR","RAWDATA","DECODEDDATA","STREAMEND","WSCONNECTED","MessageEvents","CHAT","MEMBER","GIFT","ROOMUSER","SOCIAL","LIKE","QUESTIONNEW","LINKMICBATTLE","LINKMICARMIES","LIVEINTRO","EMOTE","ENVELOPE","SUBSCRIBE","CustomEvents","FOLLOW","SHARE","_options","WeakMap","_uniqueStreamerId","_roomId","_roomInfo","_clientParams","_httpClient","_availableGifts","_websocket","_isConnecting","_isConnected","_isPollingEnabled","_isWsUpgradeDone","_setOptions","WeakSet","_setUnconnected","_retrieveRoomId","_fetchRoomInfo","_fetchAvailableGifts","_startFetchRoomPolling","_fetchRoomData","_tryUpgradeToWebsocket","_setupWebsocket","_processWebcastResponse","_handleError","WebcastPushConnection","constructor","uniqueId","options","_setOptions2","requestHeaders","requestOptions","sessionId","DEFAULT_CLIENT_PARAMS","clientParams","_setUnconnected2","connect","roomId","Error","room_id","_retrieveRoomId2","fetchRoomInfoOnConnect","_fetchRoomInfo2","status","enableExtendedGiftInfo","_fetchAvailableGifts2","_fetchRoomData2","enableRequestPolling","_startFetchRoomPolling2","state","getState","emit","err","_handleError2","disconnect","connection","connected","close","isConnected","upgradedToWebsocket","roomInfo","availableGifts","getRoomInfo","getAvailableGifts","sendMessage","text","_response$data","setSessionId","requestParams","content","response","postFormDataToWebcastApi","status_code","data","message","decodeProtobufMessage","messageType","messageBuffer","decodedWebcastResponse","_processWebcastResponse2","decodedWebcastWebsocketMessage","webcastResponse","webcastMessage","messages","decodedData","type","providedOptions","Object","assign","processInitialData","enableWebsocketUpgrade","requestPollingIntervalMs","websocketHeaders","websocketOptions","cursor","internal_ext","mainPageHtml","getMainPage","roomData","getJsonObjectFromTiktokApi","sourceType","statusCode","user","getJsonObjectFromWebcastApi","gifts","sleepMs","ms","Promise","resolve","setTimeout","isInitial","getDeserializedObjectFromWebcastApi","upgradeToWsOffered","wsUrl","internalExt","_tryUpgradeToWebsocket2","_webcastResponse$wsPa","wsParams","imprp","wsParam","compress","_setupWebsocket2","reject","cookieJar","on","wsConnection","msg","forEach","binary","filter","x","_simplifiedObj$displa","_simplifiedObj$displa2","simplifiedObj","includes","Array","isArray","giftId","extendedGiftInfo","find","id","displayType","exception","info","listenerCount","module","exports","signatureProvider","webcastProtobuf"],"sources":["/Users/gustavnielsen/Documents/Kode.nosync/tiktokgame/node_modules/tiktok-live-connector/dist/index.js"],"sourcesContent":["\"use strict\";\n\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\n\nconst {\n  EventEmitter\n} = require('node:events');\n\nconst TikTokHttpClient = require('./lib/tiktokHttpClient.js');\n\nconst WebcastWebsocket = require('./lib/webcastWebsocket.js');\n\nconst {\n  getRoomIdFromMainPageHtml,\n  validateAndNormalizeUniqueId,\n  addUniqueId,\n  removeUniqueId\n} = require('./lib/tiktokUtils.js');\n\nconst {\n  simplifyObject\n} = require('./lib/webcastDataConverter.js');\n\nconst {\n  deserializeMessage,\n  deserializeWebsocketMessage\n} = require('./lib/webcastProtobuf.js');\n\nconst Config = require('./lib/webcastConfig.js');\n\nconst ControlEvents = {\n  CONNECTED: 'connected',\n  DISCONNECTED: 'disconnected',\n  ERROR: 'error',\n  RAWDATA: 'rawData',\n  DECODEDDATA: 'decodedData',\n  STREAMEND: 'streamEnd',\n  WSCONNECTED: 'websocketConnected'\n};\nconst MessageEvents = {\n  CHAT: 'chat',\n  MEMBER: 'member',\n  GIFT: 'gift',\n  ROOMUSER: 'roomUser',\n  SOCIAL: 'social',\n  LIKE: 'like',\n  QUESTIONNEW: 'questionNew',\n  LINKMICBATTLE: 'linkMicBattle',\n  LINKMICARMIES: 'linkMicArmies',\n  LIVEINTRO: 'liveIntro',\n  EMOTE: 'emote',\n  ENVELOPE: 'envelope',\n  SUBSCRIBE: 'subscribe'\n};\nconst CustomEvents = {\n  FOLLOW: 'follow',\n  SHARE: 'share'\n};\n/**\n * Wrapper class for TikTok's internal Webcast Push Service\n */\n\nvar _options = /*#__PURE__*/new WeakMap();\n\nvar _uniqueStreamerId = /*#__PURE__*/new WeakMap();\n\nvar _roomId = /*#__PURE__*/new WeakMap();\n\nvar _roomInfo = /*#__PURE__*/new WeakMap();\n\nvar _clientParams = /*#__PURE__*/new WeakMap();\n\nvar _httpClient = /*#__PURE__*/new WeakMap();\n\nvar _availableGifts = /*#__PURE__*/new WeakMap();\n\nvar _websocket = /*#__PURE__*/new WeakMap();\n\nvar _isConnecting = /*#__PURE__*/new WeakMap();\n\nvar _isConnected = /*#__PURE__*/new WeakMap();\n\nvar _isPollingEnabled = /*#__PURE__*/new WeakMap();\n\nvar _isWsUpgradeDone = /*#__PURE__*/new WeakMap();\n\nvar _setOptions = /*#__PURE__*/new WeakSet();\n\nvar _setUnconnected = /*#__PURE__*/new WeakSet();\n\nvar _retrieveRoomId = /*#__PURE__*/new WeakSet();\n\nvar _fetchRoomInfo = /*#__PURE__*/new WeakSet();\n\nvar _fetchAvailableGifts = /*#__PURE__*/new WeakSet();\n\nvar _startFetchRoomPolling = /*#__PURE__*/new WeakSet();\n\nvar _fetchRoomData = /*#__PURE__*/new WeakSet();\n\nvar _tryUpgradeToWebsocket = /*#__PURE__*/new WeakSet();\n\nvar _setupWebsocket = /*#__PURE__*/new WeakSet();\n\nvar _processWebcastResponse = /*#__PURE__*/new WeakSet();\n\nvar _handleError = /*#__PURE__*/new WeakSet();\n\nclass WebcastPushConnection extends EventEmitter {\n  // Websocket\n  // State\n\n  /**\n   * Create a new WebcastPushConnection instance\n   * @param {string} uniqueId TikTok username (from URL)\n   * @param {object} [options] Connection options\n   * @param {boolean} [options[].processInitialData=true] Process the initital data which includes messages of the last minutes\n   * @param {boolean} [options[].fetchRoomInfoOnConnect=true] Fetch the room info (room status, streamer info, etc.) on connect (will be returned when calling connect())\n   * @param {boolean} [options[].enableExtendedGiftInfo=false] Enable this option to get extended information on 'gift' events like gift name and cost\n   * @param {boolean} [options[].enableWebsocketUpgrade=true] Use WebSocket instead of request polling if TikTok offers it\n   * @param {boolean} [options[].enableRequestPolling=true] Use request polling if no WebSocket upgrade is offered. If `false` an exception will be thrown if TikTok does not offer a WebSocket upgrade.\n   * @param {number} [options[].requestPollingIntervalMs=1000] Request polling interval if WebSocket is not used\n   * @param {string} [options[].sessionId=null] The session ID from the \"sessionid\" cookie is required if you want to send automated messages in the chat.\n   * @param {object} [options[].clientParams={}] Custom client params for Webcast API\n   * @param {object} [options[].requestHeaders={}] Custom request headers for axios\n   * @param {object} [options[].websocketHeaders={}] Custom request headers for websocket.client\n   * @param {object} [options[].requestOptions={}] Custom request options for axios. Here you can specify an `httpsAgent` to use a proxy and a `timeout` value for example.\n   * @param {object} [options[].websocketOptions={}] Custom request options for websocket.client. Here you can specify an `agent` to use a proxy and a `timeout` value for example.\n   */\n  constructor(uniqueId, options) {\n    super();\n\n    _classPrivateMethodInitSpec(this, _handleError);\n\n    _classPrivateMethodInitSpec(this, _processWebcastResponse);\n\n    _classPrivateMethodInitSpec(this, _setupWebsocket);\n\n    _classPrivateMethodInitSpec(this, _tryUpgradeToWebsocket);\n\n    _classPrivateMethodInitSpec(this, _fetchRoomData);\n\n    _classPrivateMethodInitSpec(this, _startFetchRoomPolling);\n\n    _classPrivateMethodInitSpec(this, _fetchAvailableGifts);\n\n    _classPrivateMethodInitSpec(this, _fetchRoomInfo);\n\n    _classPrivateMethodInitSpec(this, _retrieveRoomId);\n\n    _classPrivateMethodInitSpec(this, _setUnconnected);\n\n    _classPrivateMethodInitSpec(this, _setOptions);\n\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _uniqueStreamerId, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _roomId, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _roomInfo, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _clientParams, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _httpClient, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _availableGifts, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _isConnecting, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _isConnected, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _isPollingEnabled, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _isWsUpgradeDone, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateMethodGet(this, _setOptions, _setOptions2).call(this, options || {});\n\n    _classPrivateFieldSet(this, _uniqueStreamerId, validateAndNormalizeUniqueId(uniqueId));\n\n    _classPrivateFieldSet(this, _httpClient, new TikTokHttpClient(_classPrivateFieldGet(this, _options).requestHeaders, _classPrivateFieldGet(this, _options).requestOptions, _classPrivateFieldGet(this, _options).sessionId));\n\n    _classPrivateFieldSet(this, _clientParams, { ...Config.DEFAULT_CLIENT_PARAMS,\n      ..._classPrivateFieldGet(this, _options).clientParams\n    });\n\n    _classPrivateMethodGet(this, _setUnconnected, _setUnconnected2).call(this);\n  }\n\n  /**\n   * Connects to the current live stream room\n   * @param {string} [roomId] If you want to connect to a specific roomId. Otherwise the current roomId will be retrieved.\n   * @returns {Promise} Promise that will be resolved when the connection is established.\n   */\n  async connect(roomId = null) {\n    if (_classPrivateFieldGet(this, _isConnecting)) {\n      throw new Error('Already connecting!');\n    }\n\n    if (_classPrivateFieldGet(this, _isConnected)) {\n      throw new Error('Already connected!');\n    }\n\n    _classPrivateFieldSet(this, _isConnecting, true); // add streamerId to uu\n\n\n    addUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n\n    try {\n      // roomId already specified?\n      if (roomId) {\n        _classPrivateFieldSet(this, _roomId, roomId);\n\n        _classPrivateFieldGet(this, _clientParams).room_id = roomId;\n      } else {\n        await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n      } // Fetch room info if option enabled\n\n\n      if (_classPrivateFieldGet(this, _options).fetchRoomInfoOnConnect) {\n        await _classPrivateMethodGet(this, _fetchRoomInfo, _fetchRoomInfo2).call(this); // Prevent connections to finished rooms\n\n        if (_classPrivateFieldGet(this, _roomInfo).status === 4) {\n          throw new Error('LIVE has ended');\n        }\n      } // Fetch all available gift info if option enabled\n\n\n      if (_classPrivateFieldGet(this, _options).enableExtendedGiftInfo) {\n        await _classPrivateMethodGet(this, _fetchAvailableGifts, _fetchAvailableGifts2).call(this);\n      }\n\n      await _classPrivateMethodGet(this, _fetchRoomData, _fetchRoomData2).call(this, true); // Sometimes no upgrade to WebSocket is offered by TikTok\n      // In that case we use request polling (if enabled and possible)\n\n      if (!_classPrivateFieldGet(this, _isWsUpgradeDone)) {\n        if (!_classPrivateFieldGet(this, _options).enableRequestPolling) {\n          throw new Error('TikTok does not offer a websocket upgrade and request polling is disabled (`enableRequestPolling` option).');\n        }\n\n        if (!_classPrivateFieldGet(this, _options).sessionId) {\n          // We cannot use request polling if the user has no sessionid defined.\n          // The reason for this is that TikTok needs a valid signature if the user is not logged in.\n          // Signing a request every second would generate too much traffic to the signing server.\n          // If a sessionid is present a signature is not required.\n          throw new Error('TikTok does not offer a websocket upgrade. Please provide a valid `sessionId` to use request polling instead.');\n        }\n\n        _classPrivateMethodGet(this, _startFetchRoomPolling, _startFetchRoomPolling2).call(this);\n      }\n\n      _classPrivateFieldSet(this, _isConnected, true);\n\n      let state = this.getState();\n      this.emit(ControlEvents.CONNECTED, state);\n      return state;\n    } catch (err) {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Error while connecting'); // remove streamerId from uu on connect fail\n\n\n      removeUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n      throw err;\n    } finally {\n      _classPrivateFieldSet(this, _isConnecting, false);\n    }\n  }\n  /**\n   * Disconnects the connection to the live stream\n   */\n\n\n  disconnect() {\n    if (_classPrivateFieldGet(this, _isConnected)) {\n      if (_classPrivateFieldGet(this, _isWsUpgradeDone) && _classPrivateFieldGet(this, _websocket).connection.connected) {\n        _classPrivateFieldGet(this, _websocket).connection.close();\n      } // Reset state\n\n\n      _classPrivateMethodGet(this, _setUnconnected, _setUnconnected2).call(this); // remove streamerId from uu\n\n\n      removeUniqueId(_classPrivateFieldGet(this, _uniqueStreamerId));\n      this.emit(ControlEvents.DISCONNECTED);\n    }\n  }\n  /**\n   * Get the current connection state including the cached room info and all available gifts (if `enableExtendedGiftInfo` option enabled)\n   * @returns {object} current state object\n   */\n\n\n  getState() {\n    return {\n      isConnected: _classPrivateFieldGet(this, _isConnected),\n      upgradedToWebsocket: _classPrivateFieldGet(this, _isWsUpgradeDone),\n      roomId: _classPrivateFieldGet(this, _roomId),\n      roomInfo: _classPrivateFieldGet(this, _roomInfo),\n      availableGifts: _classPrivateFieldGet(this, _availableGifts)\n    };\n  }\n  /**\n   * Get the current room info (including streamer info, room status and statistics)\n   * @returns {Promise} Promise that will be resolved when the room info has been retrieved from the API\n   */\n\n\n  async getRoomInfo() {\n    // Retrieve current room_id if not connected\n    if (!_classPrivateFieldGet(this, _isConnected)) {\n      await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n    }\n\n    await _classPrivateMethodGet(this, _fetchRoomInfo, _fetchRoomInfo2).call(this);\n    return _classPrivateFieldGet(this, _roomInfo);\n  }\n  /**\n   * Get a list of all available gifts including gift name, image url, diamont cost and a lot of other information\n   * @returns {Promise} Promise that will be resolved when all available gifts has been retrieved from the API\n   */\n\n\n  async getAvailableGifts() {\n    await _classPrivateMethodGet(this, _fetchAvailableGifts, _fetchAvailableGifts2).call(this);\n    return _classPrivateFieldGet(this, _availableGifts);\n  }\n  /**\n   * Sends a chat message into the current live room using the provided session cookie\n   * @param {string} text Message Content\n   * @param {string} [sessionId] The \"sessionid\" cookie value from your TikTok Website if not provided via the constructor options\n   * @returns {Promise} Promise that will be resolved when the chat message has been submitted to the API\n   */\n\n\n  async sendMessage(text, sessionId) {\n    var _response$data;\n\n    if (sessionId) {\n      // Update sessionId\n      _classPrivateFieldGet(this, _options).sessionId = sessionId;\n    }\n\n    if (!_classPrivateFieldGet(this, _options).sessionId) {\n      throw new Error('Missing SessionId. Please provide your current SessionId to use this feature.');\n    }\n\n    try {\n      // Retrieve current room_id if not connected\n      if (!_classPrivateFieldGet(this, _isConnected)) {\n        await _classPrivateMethodGet(this, _retrieveRoomId, _retrieveRoomId2).call(this);\n      } // Add the session cookie to the CookieJar\n\n\n      _classPrivateFieldGet(this, _httpClient).setSessionId(_classPrivateFieldGet(this, _options).sessionId); // Submit the chat request\n\n\n      let requestParams = { ..._classPrivateFieldGet(this, _clientParams),\n        content: text\n      };\n      let response = await _classPrivateFieldGet(this, _httpClient).postFormDataToWebcastApi('room/chat/', requestParams, null); // Success?\n\n      if ((response === null || response === void 0 ? void 0 : response.status_code) === 0) {\n        return response.data;\n      } // Handle errors\n\n\n      switch (response === null || response === void 0 ? void 0 : response.status_code) {\n        case 20003:\n          throw new Error('Your SessionId has expired. Please provide a new one.');\n\n        default:\n          throw new Error(`TikTok responded with status code ${response === null || response === void 0 ? void 0 : response.status_code}: ${response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.message}`);\n      }\n    } catch (err) {\n      throw new Error(`Failed to send chat message. ${err.message}`);\n    }\n  }\n  /**\n   * Decodes and processes a binary webcast data package that you have received via the `rawData` event (for debugging purposes only)\n   * @param {string} messageType\n   * @param {Buffer} messageBuffer\n   */\n\n\n  async decodeProtobufMessage(messageType, messageBuffer) {\n    switch (messageType) {\n      case 'WebcastResponse':\n        {\n          let decodedWebcastResponse = deserializeMessage(messageType, messageBuffer);\n\n          _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, decodedWebcastResponse);\n\n          break;\n        }\n\n      case 'WebcastWebsocketMessage':\n        {\n          let decodedWebcastWebsocketMessage = await deserializeWebsocketMessage(messageBuffer);\n\n          if (typeof decodedWebcastWebsocketMessage.webcastResponse === 'object') {\n            _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, decodedWebcastWebsocketMessage.webcastResponse);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          let webcastMessage = deserializeMessage(messageType, messageBuffer);\n\n          _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, {\n            messages: [{\n              decodedData: webcastMessage,\n              type: messageType\n            }]\n          });\n        }\n    }\n  }\n\n}\n\nfunction _setOptions2(providedOptions) {\n  _classPrivateFieldSet(this, _options, Object.assign({\n    // Default\n    processInitialData: true,\n    fetchRoomInfoOnConnect: true,\n    enableExtendedGiftInfo: false,\n    enableWebsocketUpgrade: true,\n    enableRequestPolling: true,\n    requestPollingIntervalMs: 1000,\n    sessionId: null,\n    clientParams: {},\n    requestHeaders: {},\n    websocketHeaders: {},\n    requestOptions: {},\n    websocketOptions: {}\n  }, providedOptions));\n}\n\nfunction _setUnconnected2() {\n  _classPrivateFieldSet(this, _roomInfo, null);\n\n  _classPrivateFieldSet(this, _isConnecting, false);\n\n  _classPrivateFieldSet(this, _isConnected, false);\n\n  _classPrivateFieldSet(this, _isPollingEnabled, false);\n\n  _classPrivateFieldSet(this, _isWsUpgradeDone, false);\n\n  _classPrivateFieldGet(this, _clientParams).cursor = '';\n  _classPrivateFieldGet(this, _clientParams).internal_ext = '';\n}\n\nasync function _retrieveRoomId2() {\n  try {\n    let mainPageHtml = await _classPrivateFieldGet(this, _httpClient).getMainPage(`@${_classPrivateFieldGet(this, _uniqueStreamerId)}/live`);\n\n    try {\n      let roomId = getRoomIdFromMainPageHtml(mainPageHtml);\n\n      _classPrivateFieldSet(this, _roomId, roomId);\n\n      _classPrivateFieldGet(this, _clientParams).room_id = roomId;\n    } catch (err) {\n      // Use fallback method\n      let roomData = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromTiktokApi('api-live/user/room/', { ..._classPrivateFieldGet(this, _clientParams),\n        uniqueId: _classPrivateFieldGet(this, _uniqueStreamerId),\n        sourceType: 54\n      });\n      if (roomData.statusCode) throw new Error(`API Error ${roomData.statusCode} (${roomData.message || 'Unknown Error'})`);\n\n      _classPrivateFieldSet(this, _roomId, roomData.data.user.roomId);\n\n      _classPrivateFieldGet(this, _clientParams).room_id = roomData.data.user.roomId;\n    }\n  } catch (err) {\n    throw new Error(`Failed to retrieve room_id from page source. ${err.message}`);\n  }\n}\n\nasync function _fetchRoomInfo2() {\n  try {\n    let response = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromWebcastApi('room/info/', _classPrivateFieldGet(this, _clientParams));\n\n    _classPrivateFieldSet(this, _roomInfo, response.data);\n  } catch (err) {\n    throw new Error(`Failed to fetch room info. ${err.message}`);\n  }\n}\n\nasync function _fetchAvailableGifts2() {\n  try {\n    let response = await _classPrivateFieldGet(this, _httpClient).getJsonObjectFromWebcastApi('gift/list/', _classPrivateFieldGet(this, _clientParams));\n\n    _classPrivateFieldSet(this, _availableGifts, response.data.gifts);\n  } catch (err) {\n    throw new Error(`Failed to fetch available gifts. ${err.message}`);\n  }\n}\n\nasync function _startFetchRoomPolling2() {\n  _classPrivateFieldSet(this, _isPollingEnabled, true);\n\n  let sleepMs = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  while (_classPrivateFieldGet(this, _isPollingEnabled)) {\n    try {\n      await _classPrivateMethodGet(this, _fetchRoomData, _fetchRoomData2).call(this, false);\n    } catch (err) {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Error while fetching webcast data via request polling');\n    }\n\n    await sleepMs(_classPrivateFieldGet(this, _options).requestPollingIntervalMs);\n  }\n}\n\nasync function _fetchRoomData2(isInitial) {\n  let webcastResponse = await _classPrivateFieldGet(this, _httpClient).getDeserializedObjectFromWebcastApi('im/fetch/', _classPrivateFieldGet(this, _clientParams), 'WebcastResponse', isInitial);\n  let upgradeToWsOffered = !!webcastResponse.wsUrl;\n\n  if (!webcastResponse.cursor) {\n    if (isInitial) {\n      throw new Error('Missing cursor in initial fetch response.');\n    } else {\n      _classPrivateMethodGet(this, _handleError, _handleError2).call(this, null, 'Missing cursor in fetch response.');\n    }\n  } // Set cursor and internal_ext param to continue with the next request\n\n\n  if (webcastResponse.cursor) _classPrivateFieldGet(this, _clientParams).cursor = webcastResponse.cursor;\n  if (webcastResponse.internalExt) _classPrivateFieldGet(this, _clientParams).internal_ext = webcastResponse.internalExt;\n\n  if (isInitial) {\n    // Upgrade to Websocket offered? => Try upgrade\n    if (_classPrivateFieldGet(this, _options).enableWebsocketUpgrade && upgradeToWsOffered) {\n      await _classPrivateMethodGet(this, _tryUpgradeToWebsocket, _tryUpgradeToWebsocket2).call(this, webcastResponse);\n    }\n  } // Skip processing initial data if option disabled\n\n\n  if (isInitial && !_classPrivateFieldGet(this, _options).processInitialData) {\n    return;\n  }\n\n  _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, webcastResponse);\n}\n\nasync function _tryUpgradeToWebsocket2(webcastResponse) {\n  try {\n    var _webcastResponse$wsPa;\n\n    // Websocket specific params\n    let wsParams = {\n      imprp: ((_webcastResponse$wsPa = webcastResponse.wsParam) === null || _webcastResponse$wsPa === void 0 ? void 0 : _webcastResponse$wsPa.value) || '',\n      compress: 'gzip'\n    }; // Wait until ws connected, then stop request polling\n\n    await _classPrivateMethodGet(this, _setupWebsocket, _setupWebsocket2).call(this, webcastResponse.wsUrl, wsParams);\n\n    _classPrivateFieldSet(this, _isWsUpgradeDone, true);\n\n    _classPrivateFieldSet(this, _isPollingEnabled, false);\n\n    this.emit(ControlEvents.WSCONNECTED, _classPrivateFieldGet(this, _websocket));\n  } catch (err) {\n    _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Upgrade to websocket failed');\n  }\n}\n\nasync function _setupWebsocket2(wsUrl, wsParams) {\n  return new Promise((resolve, reject) => {\n    _classPrivateFieldSet(this, _websocket, new WebcastWebsocket(wsUrl, _classPrivateFieldGet(this, _httpClient).cookieJar, _classPrivateFieldGet(this, _clientParams), wsParams, _classPrivateFieldGet(this, _options).websocketHeaders, _classPrivateFieldGet(this, _options).websocketOptions));\n\n    _classPrivateFieldGet(this, _websocket).on('connect', wsConnection => {\n      resolve();\n      wsConnection.on('error', err => _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Websocket Error'));\n      wsConnection.on('close', () => {\n        this.disconnect();\n      });\n    });\n\n    _classPrivateFieldGet(this, _websocket).on('connectFailed', err => reject(`Websocket connection failed, ${err}`));\n\n    _classPrivateFieldGet(this, _websocket).on('webcastResponse', msg => _classPrivateMethodGet(this, _processWebcastResponse, _processWebcastResponse2).call(this, msg));\n\n    _classPrivateFieldGet(this, _websocket).on('messageDecodingFailed', err => _classPrivateMethodGet(this, _handleError, _handleError2).call(this, err, 'Websocket message decoding failed')); // Hard timeout if the WebSocketClient library does not handle connect errors correctly.\n\n\n    setTimeout(() => reject('Websocket not responding'), 30000);\n  });\n}\n\nfunction _processWebcastResponse2(webcastResponse) {\n  // Emit raw (protobuf encoded) data for a use case specific processing\n  webcastResponse.messages.forEach(message => {\n    this.emit(ControlEvents.RAWDATA, message.type, message.binary);\n  }); // Process and emit decoded data depending on the the message type\n\n  webcastResponse.messages.filter(x => x.decodedData).forEach(message => {\n    var _simplifiedObj$displa, _simplifiedObj$displa2;\n\n    let simplifiedObj = simplifyObject(message.decodedData);\n    this.emit(ControlEvents.DECODEDDATA, message.type, simplifiedObj, message.binary);\n\n    switch (message.type) {\n      case 'WebcastControlMessage':\n        // Known control actions:\n        // 3 = Stream terminated by user\n        // 4 = Stream terminated by platform moderator (ban)\n        const action = message.decodedData.action;\n\n        if ([3, 4].includes(action)) {\n          this.emit(ControlEvents.STREAMEND, {\n            action\n          });\n          this.disconnect();\n        }\n\n        break;\n\n      case 'WebcastRoomUserSeqMessage':\n        this.emit(MessageEvents.ROOMUSER, simplifiedObj);\n        break;\n\n      case 'WebcastChatMessage':\n        this.emit(MessageEvents.CHAT, simplifiedObj);\n        break;\n\n      case 'WebcastMemberMessage':\n        this.emit(MessageEvents.MEMBER, simplifiedObj);\n        break;\n\n      case 'WebcastGiftMessage':\n        // Add extended gift info if option enabled\n        if (Array.isArray(_classPrivateFieldGet(this, _availableGifts)) && simplifiedObj.giftId) {\n          simplifiedObj.extendedGiftInfo = _classPrivateFieldGet(this, _availableGifts).find(x => x.id === simplifiedObj.giftId);\n        }\n\n        this.emit(MessageEvents.GIFT, simplifiedObj);\n        break;\n\n      case 'WebcastSocialMessage':\n        this.emit(MessageEvents.SOCIAL, simplifiedObj);\n\n        if ((_simplifiedObj$displa = simplifiedObj.displayType) !== null && _simplifiedObj$displa !== void 0 && _simplifiedObj$displa.includes('follow')) {\n          this.emit(CustomEvents.FOLLOW, simplifiedObj);\n        }\n\n        if ((_simplifiedObj$displa2 = simplifiedObj.displayType) !== null && _simplifiedObj$displa2 !== void 0 && _simplifiedObj$displa2.includes('share')) {\n          this.emit(CustomEvents.SHARE, simplifiedObj);\n        }\n\n        break;\n\n      case 'WebcastLikeMessage':\n        this.emit(MessageEvents.LIKE, simplifiedObj);\n        break;\n\n      case 'WebcastQuestionNewMessage':\n        this.emit(MessageEvents.QUESTIONNEW, simplifiedObj);\n        break;\n\n      case 'WebcastLinkMicBattle':\n        this.emit(MessageEvents.LINKMICBATTLE, simplifiedObj);\n        break;\n\n      case 'WebcastLinkMicArmies':\n        this.emit(MessageEvents.LINKMICARMIES, simplifiedObj);\n        break;\n\n      case 'WebcastLiveIntroMessage':\n        this.emit(MessageEvents.LIVEINTRO, simplifiedObj);\n        break;\n\n      case 'WebcastEmoteChatMessage':\n        this.emit(MessageEvents.EMOTE, simplifiedObj);\n        break;\n\n      case 'WebcastEnvelopeMessage':\n        this.emit(MessageEvents.ENVELOPE, simplifiedObj);\n        break;\n\n      case 'WebcastSubNotifyMessage':\n        this.emit(MessageEvents.SUBSCRIBE, simplifiedObj);\n        break;\n    }\n  });\n}\n\nfunction _handleError2(exception, info) {\n  if (this.listenerCount(ControlEvents.ERROR) > 0) {\n    this.emit(ControlEvents.ERROR, {\n      info,\n      exception\n    });\n  }\n}\n\nmodule.exports = {\n  WebcastPushConnection,\n  signatureProvider: require('./lib/tiktokSignatureProvider'),\n  webcastProtobuf: require('./lib/webcastProtobuf.js')\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}